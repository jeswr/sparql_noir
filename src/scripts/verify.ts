/**
 * verify.ts - Verify ZK proofs for SPARQL query results
 * 
 * This script can verify:
 * 1. Standalone signature proofs (from sign.ts)
 * 2. SPARQL query proofs (from prove.ts)
 */
import { UltraHonkBackend } from '@aztec/bb.js';
import { type CompiledCircuit, Noir } from '@noir-lang/noir_js';
import { Command } from 'commander';
import { existsSync, readFileSync } from 'fs';
import { join, resolve } from 'path';

const program = new Command();

program
  .name('verify')
  .description('Verify ZK proofs generated by sign.ts or prove.ts')
  .requiredOption('-i, --input <path>', 'Path to proof JSON (from prove.ts) or signed JSON (from sign.ts)')
  .option('-c, --circuit <path>', 'Path to compiled circuit directory (required for SPARQL proofs)')
  .option('--signature-only', 'Verify signature proof only (uses built-in signature circuit)')
  .option('--threads <n>', 'Number of threads for verification', '6')
  .addHelpText('after', `
Examples:
  # Verify a SPARQL query proof
  $ npm run verify -- -i proof.json -c output

  # Verify a signature-only proof
  $ npm run verify -- -i signed.json --signature-only
`)
  .parse();

const opts = program.opts<{
  input: string;
  circuit?: string;
  signatureOnly?: boolean;
  threads: string;
}>();

const jsonPath = resolve(process.cwd(), opts.input);

if (!existsSync(jsonPath)) {
  console.error(`Error: Input file '${jsonPath}' does not exist.`);
  process.exit(1);
}

const json = JSON.parse(readFileSync(jsonPath, 'utf8'));

// Determine proof type
const isProveOutput = json.proofs && Array.isArray(json.proofs);
const isSignatureMode = opts.signatureOnly || (!isProveOutput && !opts.circuit);

async function verifySignatureProof() {
  // Signature-only verification (original behavior)
  const circuitPath = join(process.cwd(), 'noir', 'bin', 'signature', 'target', 'signature.json');
  
  if (!existsSync(circuitPath)) {
    console.error(`Error: Signature circuit not found at '${circuitPath}'.`);
    console.error('Run: cd noir/bin/signature && nargo compile');
    process.exit(1);
  }

  const verifyCircuit = JSON.parse(readFileSync(circuitPath, 'utf8'));
  const noir = new Noir(verifyCircuit as unknown as CompiledCircuit);
  const backend = new UltraHonkBackend(verifyCircuit.bytecode, { threads: parseInt(opts.threads) });

  try {
    console.time('Witness generation');
    const { witness } = await noir.execute({
      public_key: json.pubKey,
      root: {
        value: json.root,
        signature: json.signature,
      },
    });
    console.timeEnd('Witness generation');

    console.time('Proof generation');
    const proof = await backend.generateProof(witness);
    console.timeEnd('Proof generation');

    console.time('Proof verification');
    const isValid = await backend.verifyProof(proof);
    console.timeEnd('Proof verification');

    if (!isValid) {
      throw new Error('Signature verification failed');
    }

    console.log('\n✓ Signature proof verified successfully');
  } catch (error) {
    console.error('\n✗ Signature verification failed:', (error as Error).message);
    process.exit(1);
  } finally {
    backend.destroy();
  }
}

async function verifySparqlProof() {
  if (!opts.circuit) {
    console.error('Error: --circuit path required for SPARQL proof verification.');
    process.exit(1);
  }

  const circuitDir = resolve(process.cwd(), opts.circuit);
  const targetDir = join(circuitDir, 'target');

  if (!existsSync(targetDir)) {
    console.error(`Error: Circuit target directory '${targetDir}' does not exist.`);
    process.exit(1);
  }

  const circuitFiles = (await import('fs')).readdirSync(targetDir).filter((f: string) => f.endsWith('.json'));
  if (circuitFiles.length === 0) {
    console.error(`Error: No compiled circuit JSON found in '${targetDir}'.`);
    process.exit(1);
  }

  const circuitJsonPath = join(targetDir, circuitFiles[0]!);
  console.log(`Loading circuit: ${circuitJsonPath}`);

  const circuit = JSON.parse(readFileSync(circuitJsonPath, 'utf8')) as CompiledCircuit;
  const backend = new UltraHonkBackend(circuit.bytecode, { threads: parseInt(opts.threads) });

  const proofs = json.proofs || [json];
  let verifiedCount = 0;
  let failedCount = 0;

  for (let i = 0; i < proofs.length; i++) {
    const proofData = proofs[i];
    console.log(`\nVerifying proof ${i + 1}/${proofs.length}...`);

    try {
      // Reconstruct proof object
      const proof = {
        proof: proofData.proof instanceof Uint8Array
          ? proofData.proof
          : new Uint8Array(proofData.proof),
        publicInputs: proofData.publicInputs,
      };

      console.time(`  Verification`);
      const isValid = await backend.verifyProof(proof);
      console.timeEnd(`  Verification`);

      if (isValid) {
        console.log(`  ✓ Proof ${i + 1} verified`);
        verifiedCount++;
      } else {
        console.log(`  ✗ Proof ${i + 1} invalid`);
        failedCount++;
      }
    } catch (error) {
      console.error(`  ✗ Proof ${i + 1} error:`, (error as Error).message);
      failedCount++;
    }
  }

  backend.destroy();

  console.log(`\n========================================`);
  console.log(`Total proofs: ${proofs.length}`);
  console.log(`Verified: ${verifiedCount}`);
  console.log(`Failed: ${failedCount}`);

  if (failedCount > 0) {
    process.exit(1);
  }

  console.log('\n✓ All proofs verified successfully');
}

// Main execution
if (isSignatureMode) {
  console.log('Verifying signature proof...\n');
  verifySignatureProof();
} else {
  console.log('Verifying SPARQL query proof(s)...\n');
  verifySparqlProof();
}
